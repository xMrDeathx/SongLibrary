// Package frontendapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package frontendapi

import (
	"fmt"
	"net/http"

	"github.com/gorilla/mux"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Song defines model for Song.
type Song struct {
	Group string             `json:"group"`
	Id    openapi_types.UUID `json:"id"`
	Song  string             `json:"song"`
}

// SongDetail defines model for SongDetail.
type SongDetail struct {
	Link        string `json:"link"`
	ReleaseDate string `json:"releaseDate"`
	Text        string `json:"text"`
}

// GetSongTextResponse defines model for getSongTextResponse.
type GetSongTextResponse struct {
	Link        string   `json:"link"`
	ReleaseDate string   `json:"releaseDate"`
	Song        Song     `json:"song"`
	Text        []string `json:"text"`
}

// SongsResponse defines model for songsResponse.
type SongsResponse struct {
	Songs []Song `json:"songs"`
}

// AddSongParams defines parameters for AddSong.
type AddSongParams struct {
	Group string `form:"group" json:"group"`
	Song  string `form:"song" json:"song"`
}

// GetSongsParams defines parameters for GetSongs.
type GetSongsParams struct {
	Group       *string `form:"group,omitempty" json:"group,omitempty"`
	Song        *string `form:"song,omitempty" json:"song,omitempty"`
	ReleaseDate *string `form:"releaseDate,omitempty" json:"releaseDate,omitempty"`
	Text        *string `form:"text,omitempty" json:"text,omitempty"`
	Link        *string `form:"link,omitempty" json:"link,omitempty"`
	Page        *int    `form:"page,omitempty" json:"page,omitempty"`
	Limit       *int    `form:"limit,omitempty" json:"limit,omitempty"`
}

// UpdateSongParams defines parameters for UpdateSong.
type UpdateSongParams struct {
	Group       *string `form:"group,omitempty" json:"group,omitempty"`
	Song        *string `form:"song,omitempty" json:"song,omitempty"`
	ReleaseDate *string `form:"releaseDate,omitempty" json:"releaseDate,omitempty"`
	Text        *string `form:"text,omitempty" json:"text,omitempty"`
	Link        *string `form:"link,omitempty" json:"link,omitempty"`
}

// GetSongTextParams defines parameters for GetSongText.
type GetSongTextParams struct {
	Page  int `form:"page" json:"page"`
	Limit int `form:"limit" json:"limit"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /songlibrary/info)
	AddSong(w http.ResponseWriter, r *http.Request, params AddSongParams)

	// (GET /songlibrary/songs)
	GetSongs(w http.ResponseWriter, r *http.Request, params GetSongsParams)

	// (DELETE /songlibrary/songs/{id})
	DeleteSong(w http.ResponseWriter, r *http.Request, id openapi_types.UUID)

	// (PUT /songlibrary/songs/{id})
	UpdateSong(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params UpdateSongParams)

	// (GET /songlibrary/songs/{id}/verses)
	GetSongText(w http.ResponseWriter, r *http.Request, id openapi_types.UUID, params GetSongTextParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AddSong operation middleware
func (siw *ServerInterfaceWrapper) AddSong(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AddSongParams

	// ------------- Required query parameter "group" -------------

	if paramValue := r.URL.Query().Get("group"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "group"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "group", r.URL.Query(), &params.Group)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group", Err: err})
		return
	}

	// ------------- Required query parameter "song" -------------

	if paramValue := r.URL.Query().Get("song"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "song"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "song", r.URL.Query(), &params.Song)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "song", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddSong(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSongs operation middleware
func (siw *ServerInterfaceWrapper) GetSongs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSongsParams

	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", r.URL.Query(), &params.Group)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group", Err: err})
		return
	}

	// ------------- Optional query parameter "song" -------------

	err = runtime.BindQueryParameter("form", true, false, "song", r.URL.Query(), &params.Song)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "song", Err: err})
		return
	}

	// ------------- Optional query parameter "releaseDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "releaseDate", r.URL.Query(), &params.ReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "releaseDate", Err: err})
		return
	}

	// ------------- Optional query parameter "text" -------------

	err = runtime.BindQueryParameter("form", true, false, "text", r.URL.Query(), &params.Text)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "text", Err: err})
		return
	}

	// ------------- Optional query parameter "link" -------------

	err = runtime.BindQueryParameter("form", true, false, "link", r.URL.Query(), &params.Link)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "link", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSongs(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteSong operation middleware
func (siw *ServerInterfaceWrapper) DeleteSong(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "id", mux.Vars(r)["id"], &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSong(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateSong operation middleware
func (siw *ServerInterfaceWrapper) UpdateSong(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "id", mux.Vars(r)["id"], &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateSongParams

	// ------------- Optional query parameter "group" -------------

	err = runtime.BindQueryParameter("form", true, false, "group", r.URL.Query(), &params.Group)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "group", Err: err})
		return
	}

	// ------------- Optional query parameter "song" -------------

	err = runtime.BindQueryParameter("form", true, false, "song", r.URL.Query(), &params.Song)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "song", Err: err})
		return
	}

	// ------------- Optional query parameter "releaseDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "releaseDate", r.URL.Query(), &params.ReleaseDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "releaseDate", Err: err})
		return
	}

	// ------------- Optional query parameter "text" -------------

	err = runtime.BindQueryParameter("form", true, false, "text", r.URL.Query(), &params.Text)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "text", Err: err})
		return
	}

	// ------------- Optional query parameter "link" -------------

	err = runtime.BindQueryParameter("form", true, false, "link", r.URL.Query(), &params.Link)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "link", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateSong(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSongText operation middleware
func (siw *ServerInterfaceWrapper) GetSongText(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "id", mux.Vars(r)["id"], &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSongTextParams

	// ------------- Required query parameter "page" -------------

	if paramValue := r.URL.Query().Get("page"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "page"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Required query parameter "limit" -------------

	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "limit"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSongText(w, r, id, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{})
}

type GorillaServerOptions struct {
	BaseURL          string
	BaseRouter       *mux.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r *mux.Router) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r *mux.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options GorillaServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = mux.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.HandleFunc(options.BaseURL+"/songlibrary/info", wrapper.AddSong).Methods("GET")

	r.HandleFunc(options.BaseURL+"/songlibrary/songs", wrapper.GetSongs).Methods("GET")

	r.HandleFunc(options.BaseURL+"/songlibrary/songs/{id}", wrapper.DeleteSong).Methods("DELETE")

	r.HandleFunc(options.BaseURL+"/songlibrary/songs/{id}", wrapper.UpdateSong).Methods("PUT")

	r.HandleFunc(options.BaseURL+"/songlibrary/songs/{id}/verses", wrapper.GetSongText).Methods("GET")

	return r
}
